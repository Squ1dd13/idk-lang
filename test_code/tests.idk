proc testForLoops() {
    print(" => Three-part for loop");
    for let i = 0; i < 10; i++ {
        print(i);
    }

    print(" => Two-part for loop");
    for let i = 0; i < 10 {
        print(i);
        i++;
    }

    print(" => One-part for loop");
    for let i = 0 {
        if i >= 10 {
            break;
        }

        print(i);
        i++;
    }

    print(" => Zero-part for loop");

    let i = 0;
    for {
        if i >= 10 {
            break;
        }

        print(i);
        i++;
    }

    print(" => Nested for loop break");

    for let x = 0; x < 10; x++ {
        for let y = 0; y < 10; y++ {
            print(x);
            print(y);
            print("");

            if x + y == 10 {
                print("Breaking outer loop!");
                break outerLoop;
            }
        }
    } outerLoop;
}

proc testReferenceChanges() {
    let a = 1;
    let ref -> a;

    if ref != 1 {
        fatal("Reference not passing through to target.");
    }

    a = 2;

    if ref as int != 2 {
        fatal("Reference value did not change after value change.");
    }

    ref = 1;

    if a != 1 {
        fatal("Value did not change after setting through reference.");
    }

    int b = 3;
    ref -> b;

    if ref != 3 {
        fatal("Reference does not resolve to redirected target.");
    }

    if a == 3 {
        fatal("Redirection changed previous target's value.");
    }

    ref = 4;

    if b != 4 {
        fatal("Redirected reference did not change new target's value.");
    }

    if a == 4 {
        fatal("Redirected reference changed previous target's value.");
    }

    print("All reference change tests passed.");
}

proc testReturnValues() {
    int someFunction(int a, int b) {
        return a + b;
    }

    int result = someFunction(1, 2);

    if result != 3 {
        fatal("1 + 2 != 3");
    }

    print("All return value tests passed.");
}

proc testIndexedAccess() {
    #string someStrings = {
        "this",
        "is",
        "a",
        "collection"
    };

    if someStrings[0] != "this" {
        fatal("Failed index access test!");
    }

    someStrings[1] = "might be";

    if someStrings[1] != "might be" {
        fatal("Failed index assignment test!");
    }

    print("All index tests passed.");
}

proc Array(Type someType) {
    return #someType;
}

proc testOperators() {
    if (1 + 2) != 3 {
        fatal("Failed basic test.");
    }

    if (1 + -2 + 3 + -4 + 5 + -6) != -3 {
        fatal("Failed addition operator test.");
    }

    if (1 - -2 - 3 - -4 - 5 - -6) != 5 {
        fatal("Failed subtraction operator test.");
    }

    if (1 * 2 * -3 * 4 * -5) != 120 {
        fatal("Failed multiplication operator test.");
    }

    if (-5 % 2) != 1 {
        fatal("Failed modulus operator test.");
    }

    int returnNumber(int a, int b) {
        return a * b;
    }

    int giveMeNumber(int a, int b) {
        return a + b;
    }

    int result = (2 + (returnNumber((((2 + 4) / 1) / (2 + 4)) * 2, 3) * giveMeNumber(1, 1)) + giveMeNumber(1, 3)) / 3;
    if result != 6 {
        fatal("Failed complex function-based expression.");
    }

    // Create an array of function references.
    Array(@any) functions = {
        -> returnNumber,
        -> giveMeNumber
    };

    print("We have this many functions:");
    print(functions.length);

    int result2 = (2 + (functions[0]((((2 + 4) / 1) / (2 + 4)) * 2, 3) * functions[1](1, 1)) + functions[1](1, 3)) / 3;
    if result2 != 6 {
        fatal("Failed complex function/array-based expression.");
    }
    
    print(result2);

    print("All operator tests passed.");
}

testReferenceChanges();
testForLoops();
testReturnValues();
testIndexedAccess();
testOperators();